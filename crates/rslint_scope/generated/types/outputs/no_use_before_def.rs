#![allow(
    path_statements,
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::missing_safety_doc,
    clippy::match_single_binding,
    clippy::ptr_arg,
    clippy::redundant_closure,
    clippy::needless_lifetimes,
    clippy::borrowed_box,
    clippy::map_clone,
    clippy::toplevel_ref_arg,
    clippy::double_parens,
    clippy::collapsible_if,
    clippy::clone_on_copy,
    clippy::unused_unit,
    clippy::deref_addrof,
    clippy::clone_on_copy,
    clippy::needless_return,
    clippy::op_ref,
    clippy::match_like_matches_macro,
    clippy::comparison_chain,
    clippy::len_zero,
    clippy::extra_unused_lifetimes
)]

use ::num::One;
use ::std::ops::Deref;

use ::differential_dataflow::collection;
use ::timely::communication;
use ::timely::dataflow::scopes;
use ::timely::worker;

use ::ddlog_derive::{FromRecord, IntoRecord, Mutator};
use ::differential_datalog::ddval::DDValue;
use ::differential_datalog::ddval::DDValConvert;
use ::differential_datalog::program;
use ::differential_datalog::program::TupleTS;
use ::differential_datalog::program::XFormArrangement;
use ::differential_datalog::program::XFormCollection;
use ::differential_datalog::program::Weight;
use ::differential_datalog::record::FromRecord;
use ::differential_datalog::record::IntoRecord;
use ::differential_datalog::record::Mutator;
use ::serde::Deserialize;
use ::serde::Serialize;


// `usize` and `isize` are builtin Rust types; we therefore declare an alias to DDlog's `usize` and
// `isize`.
pub type std_usize = u64;
pub type std_isize = i64;


#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, IntoRecord, Mutator, Default, Serialize, Deserialize, FromRecord)]
#[ddlog(rename = "outputs::no_use_before_def::NoUseBeforeDef")]
pub struct NoUseBeforeDef {
    pub name: types__ast::Name,
    pub used: types__ast::ExprId,
    pub used_in: types__ast::Span,
    pub declared: types__ast::AnyId,
    pub declared_in: types__ast::Span
}
impl abomonation::Abomonation for NoUseBeforeDef{}
impl ::std::fmt::Display for NoUseBeforeDef {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            NoUseBeforeDef{name,used,used_in,declared,declared_in} => {
                __formatter.write_str("outputs::no_use_before_def::NoUseBeforeDef{")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(used, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(used_in, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(declared, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(declared_in, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for NoUseBeforeDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub static __Rule_outputs_no_use_before_def_NoUseBeforeDef_0 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_use_before_def::NoUseBeforeDef[(outputs::no_use_before_def::NoUseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in}: outputs::no_use_before_def::NoUseBeforeDef)] :- config::EnableNoUseBeforeDef[(config::EnableNoUseBeforeDef{.file=(file: ast::FileId), .config=(_: ddlog_std::Ref<config::NoUseBeforeDefConfig>)}: config::EnableNoUseBeforeDef)], inputs::NameRef[(inputs::NameRef{.expr_id=(expr@ (ast::ExprId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::ExprId)), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(stmt: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .kind=(ast::StmtVarDecl{}: ast::StmtKind), .scope=(declared_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Statement)], ((declared_scope != used_scope) and (used_in < declared_in)). */
                                                                                                                                        program::Rule::ArrangementRule {
                                                                                                                                            description: std::borrow::Cow::from( "outputs::no_use_before_def::NoUseBeforeDef(.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in) :- config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in), not inputs::New(.expr_id=_, .object=ddlog_std::Some{.x=expr}, .args=_), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=stmt})), inputs::Statement(.id=stmt, .kind=ast::StmtVarDecl{}, .scope=declared_scope, .span=declared_in), ((declared_scope != used_scope) and (used_in < declared_in))."),
                                                                                                                                            arr: ( 6, 0),
                                                                                                                                            xform: XFormArrangement::Join{
                                                                                                                                                       description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name)"),
                                                                                                                                                       ffun: None,
                                                                                                                                                       arrangement: (43,1),
                                                                                                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                       {
                                                                                                                                                           let ref file = match *<types__config::EnableNoUseBeforeDef>::from_ddvalue_ref(__v1) {
                                                                                                                                                               types__config::EnableNoUseBeforeDef{file: ref file, config: _} => (*file).clone(),
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           let (ref expr, ref name) = match *<types__inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                                                                                                               types__inputs::NameRef{expr_id: ref expr, value: ref name} => match expr {
                                                                                                                                                                                                                                 types__ast::ExprId{id: _, file: _} => ((*expr).clone(), (*name).clone()),
                                                                                                                                                                                                                                 _ => return None
                                                                                                                                                                                                                             },
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           Some((ddlog_std::tuple2((*expr).clone(), (*name).clone())).into_ddvalue())
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                               description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name) by (expr)"),
                                                                                                                                                                               afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                               {
                                                                                                                                                                                   let ddlog_std::tuple2(ref expr, ref name) = *<ddlog_std::tuple2<types__ast::ExprId, internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                   Some((((*expr).clone()).into_ddvalue(), (ddlog_std::tuple2((*expr).clone(), (*name).clone())).into_ddvalue()))
                                                                                                                                                                               }
                                                                                                                                                                               __f},
                                                                                                                                                                               next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                  description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in)"),
                                                                                                                                                                                                  ffun: None,
                                                                                                                                                                                                  arrangement: (27,3),
                                                                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let ddlog_std::tuple2(ref expr, ref name) = *<ddlog_std::tuple2<types__ast::ExprId, internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                      let (ref used_scope, ref used_in) = match *<types__inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                          types__inputs::Expression{id: _, kind: types__ast::ExprKind::ExprNameRef{}, scope: ref used_scope, span: ref used_in} => ((*used_scope).clone(), (*used_in).clone()),
                                                                                                                                                                                                          _ => return None
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((ddlog_std::tuple4((*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue())
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                          description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in) by (expr)"),
                                                                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                          {
                                                                                                                                                                                                                              let ddlog_std::tuple4(ref expr, ref name, ref used_scope, ref used_in) = *<ddlog_std::tuple4<types__ast::ExprId, internment::Intern<String>, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                              Some((((*expr).clone()).into_ddvalue(), (ddlog_std::tuple4((*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue()))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                          __f},
                                                                                                                                                                                                                          next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                                                                             description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in), not inputs::New(.expr_id=_, .object=ddlog_std::Some{.x=expr}, .args=_)"),
                                                                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                                                                             arrangement: (44,1),
                                                                                                                                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                     description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in), not inputs::New(.expr_id=_, .object=ddlog_std::Some{.x=expr}, .args=_) by (name, used_scope)"),
                                                                                                                                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         let ddlog_std::tuple4(ref expr, ref name, ref used_scope, ref used_in) = *<ddlog_std::tuple4<types__ast::ExprId, internment::Intern<String>, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                         Some(((ddlog_std::tuple2((*name).clone(), (*used_scope).clone())).into_ddvalue(), (ddlog_std::tuple4((*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                                                                     next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                        description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in), not inputs::New(.expr_id=_, .object=ddlog_std::Some{.x=expr}, .args=_), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=stmt}))"),
                                                                                                                                                                                                                                                                                        ffun: None,
                                                                                                                                                                                                                                                                                        arrangement: (61,2),
                                                                                                                                                                                                                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            let ddlog_std::tuple4(ref expr, ref name, ref used_scope, ref used_in) = *<ddlog_std::tuple4<types__ast::ExprId, internment::Intern<String>, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                                            let (ref declared, ref stmt) = match *<crate::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                                                                crate::name_in_scope::NameInScope{name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                                                                                                                                                                                    types__ast::AnyId::AnyIdStmt{stmt: ref stmt} => ((*declared).clone(), (*stmt).clone()),
                                                                                                                                                                                                                                                                                                                                                                                    _ => return None
                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                _ => return None
                                                                                                                                                                                                                                                                                            };
                                                                                                                                                                                                                                                                                            Some((ddlog_std::tuple6((*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone(), (*declared).clone(), (*stmt).clone())).into_ddvalue())
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        __f},
                                                                                                                                                                                                                                                                                        next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                                                                description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in), not inputs::New(.expr_id=_, .object=ddlog_std::Some{.x=expr}, .args=_), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=stmt})) by (stmt)"),
                                                                                                                                                                                                                                                                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                    let ddlog_std::tuple6(ref expr, ref name, ref used_scope, ref used_in, ref declared, ref stmt) = *<ddlog_std::tuple6<types__ast::ExprId, internment::Intern<String>, types__ast::ScopeId, types__ast::Span, types__ast::AnyId, types__ast::StmtId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                                                                    Some((((*stmt).clone()).into_ddvalue(), (ddlog_std::tuple5((*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                                                                next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                                                                   description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::NameRef(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .value=name), inputs::Expression(.id=expr, .kind=ast::ExprNameRef{}, .scope=used_scope, .span=used_in), not inputs::New(.expr_id=_, .object=ddlog_std::Some{.x=expr}, .args=_), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=stmt})), inputs::Statement(.id=stmt, .kind=ast::StmtVarDecl{}, .scope=declared_scope, .span=declared_in)"),
                                                                                                                                                                                                                                                                                                                                   ffun: None,
                                                                                                                                                                                                                                                                                                                                   arrangement: (47,1),
                                                                                                                                                                                                                                                                                                                                   jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                       let ddlog_std::tuple5(ref expr, ref name, ref used_scope, ref used_in, ref declared) = *<ddlog_std::tuple5<types__ast::ExprId, internment::Intern<String>, types__ast::ScopeId, types__ast::Span, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                                                                                       let (ref declared_scope, ref declared_in) = match *<types__inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                                                                                                           types__inputs::Statement{id: _, kind: types__ast::StmtKind::StmtVarDecl{}, scope: ref declared_scope, span: ref declared_in} => ((*declared_scope).clone(), (*declared_in).clone()),
                                                                                                                                                                                                                                                                                                                                           _ => return None
                                                                                                                                                                                                                                                                                                                                       };
                                                                                                                                                                                                                                                                                                                                       if !(((&*declared_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                                                                                                                                                       Some(((NoUseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                   __f},
                                                                                                                                                                                                                                                                                                                                   next: Box::new(None)
                                                                                                                                                                                                                                                                                                                               })
                                                                                                                                                                                                                                                                                                            }))
                                                                                                                                                                                                                                                                                    })
                                                                                                                                                                                                                                                                 }))
                                                                                                                                                                                                                                         })
                                                                                                                                                                                                                      }))
                                                                                                                                                                                              })
                                                                                                                                                                           }))
                                                                                                                                                   }
                                                                                                                                        });
pub static __Rule_outputs_no_use_before_def_NoUseBeforeDef_1 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_use_before_def::NoUseBeforeDef[(outputs::no_use_before_def::NoUseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in}: outputs::no_use_before_def::NoUseBeforeDef)] :- __Prefix_0[((file: ast::FileId), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdClass{.class=(class: ast::ClassId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(decl_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((decl_scope != used_scope) and (used_in < declared_in)). */
                                                                                                                                        program::Rule::ArrangementRule {
                                                                                                                                            description: std::borrow::Cow::from( "outputs::no_use_before_def::NoUseBeforeDef(.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in) :- __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdClass{.class=class})), inputs::Class(.id=class, .name=ddlog_std::Some{.x=ast::Spanned{.data=_, .span=declared_in}}, .parent=_, .elements=_, .scope=decl_scope, .exported=_), ((decl_scope != used_scope) and (used_in < declared_in))."),
                                                                                                                                            arr: ( 0, 0),
                                                                                                                                            xform: XFormArrangement::Join{
                                                                                                                                                       description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=callee, .value=name)"),
                                                                                                                                                       ffun: None,
                                                                                                                                                       arrangement: (43,2),
                                                                                                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                       {
                                                                                                                                                           let (ref file, ref expr, ref object, ref used_scope, ref used_in) = match *<ddlog_std::tuple5<types__ast::FileId, types__ast::ExprId, types__ast::ExprId, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref(__v1) {
                                                                                                                                                               ddlog_std::tuple5(ref file, ref expr, ref object, ref used_scope, ref used_in) => ((*file).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone()),
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           let (ref callee, ref name) = match *<types__inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                                                                                                               types__inputs::NameRef{expr_id: ref callee, value: ref name} => ((*callee).clone(), (*name).clone()),
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           Some((ddlog_std::tuple4((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue())
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                               description: std::borrow::Cow::from("arrange __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=callee, .value=name) by (name, used_scope)"),
                                                                                                                                                                               afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                               {
                                                                                                                                                                                   let ddlog_std::tuple4(ref expr, ref used_scope, ref used_in, ref name) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                   Some(((ddlog_std::tuple2((*name).clone(), (*used_scope).clone())).into_ddvalue(), (ddlog_std::tuple4((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue()))
                                                                                                                                                                               }
                                                                                                                                                                               __f},
                                                                                                                                                                               next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                  description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdClass{.class=class}))"),
                                                                                                                                                                                                  ffun: None,
                                                                                                                                                                                                  arrangement: (61,3),
                                                                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let ddlog_std::tuple4(ref expr, ref used_scope, ref used_in, ref name) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                      let (ref declared, ref class) = match *<crate::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                          crate::name_in_scope::NameInScope{name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                                                                                              types__ast::AnyId::AnyIdClass{class: ref class} => ((*declared).clone(), (*class).clone()),
                                                                                                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                                                                                                          },
                                                                                                                                                                                                          _ => return None
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((ddlog_std::tuple6((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue())
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                          description: std::borrow::Cow::from("arrange __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdClass{.class=class})) by (class)"),
                                                                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                          {
                                                                                                                                                                                                                              let ddlog_std::tuple6(ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<ddlog_std::tuple6<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId, types__ast::ClassId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                              Some((((*class).clone()).into_ddvalue(), (ddlog_std::tuple5((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                          __f},
                                                                                                                                                                                                                          next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                             description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdClass{.class=class})), inputs::Class(.id=class, .name=ddlog_std::Some{.x=ast::Spanned{.data=_, .span=declared_in}}, .parent=_, .elements=_, .scope=decl_scope, .exported=_)"),
                                                                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                                                                             arrangement: (16,0),
                                                                                                                                                                                                                                             jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                 let ddlog_std::tuple5(ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<ddlog_std::tuple5<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                 let (ref declared_in, ref decl_scope) = match *<types__inputs::Class>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                     types__inputs::Class{id: _, name: ddlog_std::Option::Some{x: types__ast::Spanned{data: _, span: ref declared_in}}, parent: _, elements: _, scope: ref decl_scope, exported: _} => ((*declared_in).clone(), (*decl_scope).clone()),
                                                                                                                                                                                                                                                     _ => return None
                                                                                                                                                                                                                                                 };
                                                                                                                                                                                                                                                 if !(((&*decl_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                                                                 Some(((NoUseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone()})).into_ddvalue())
                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                             __f},
                                                                                                                                                                                                                                             next: Box::new(None)
                                                                                                                                                                                                                                         })
                                                                                                                                                                                                                      }))
                                                                                                                                                                                              })
                                                                                                                                                                           }))
                                                                                                                                                   }
                                                                                                                                        });
pub static __Rule_outputs_no_use_before_def_NoUseBeforeDef_2 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_use_before_def::NoUseBeforeDef[(outputs::no_use_before_def::NoUseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in}: outputs::no_use_before_def::NoUseBeforeDef)] :- config::EnableNoUseBeforeDef[(config::EnableNoUseBeforeDef{.file=(file: ast::FileId), .config=(_: ddlog_std::Ref<config::NoUseBeforeDefConfig>)}: config::EnableNoUseBeforeDef)], inputs::Call[(inputs::Call{.expr_id=(expr@ (ast::ExprId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::ExprId)), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdFunc{.func=(func: ast::FuncId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(decl_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], ((decl_scope != used_scope) and (used_in < declared_in)). */
                                                                                                                                        program::Rule::ArrangementRule {
                                                                                                                                            description: std::borrow::Cow::from( "outputs::no_use_before_def::NoUseBeforeDef(.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in) :- config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in), inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdFunc{.func=func})), inputs::Function(.id=func, .name=ddlog_std::Some{.x=ast::Spanned{.data=_, .span=declared_in}}, .scope=decl_scope, .body=_, .exported=_), ((decl_scope != used_scope) and (used_in < declared_in))."),
                                                                                                                                            arr: ( 6, 0),
                                                                                                                                            xform: XFormArrangement::Join{
                                                                                                                                                       description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_)"),
                                                                                                                                                       ffun: None,
                                                                                                                                                       arrangement: (15,0),
                                                                                                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                       {
                                                                                                                                                           let ref file = match *<types__config::EnableNoUseBeforeDef>::from_ddvalue_ref(__v1) {
                                                                                                                                                               types__config::EnableNoUseBeforeDef{file: ref file, config: _} => (*file).clone(),
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           let (ref expr, ref callee) = match *<types__inputs::Call>::from_ddvalue_ref(__v2) {
                                                                                                                                                               types__inputs::Call{expr_id: ref expr, callee: ddlog_std::Option::Some{x: ref callee}, args: _} => match expr {
                                                                                                                                                                                                                                                                      types__ast::ExprId{id: _, file: _} => ((*expr).clone(), (*callee).clone()),
                                                                                                                                                                                                                                                                      _ => return None
                                                                                                                                                                                                                                                                  },
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           Some((ddlog_std::tuple2((*expr).clone(), (*callee).clone())).into_ddvalue())
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                               description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_) by (expr)"),
                                                                                                                                                                               afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                               {
                                                                                                                                                                                   let ddlog_std::tuple2(ref expr, ref callee) = *<ddlog_std::tuple2<types__ast::ExprId, types__ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                   Some((((*expr).clone()).into_ddvalue(), (ddlog_std::tuple2((*expr).clone(), (*callee).clone())).into_ddvalue()))
                                                                                                                                                                               }
                                                                                                                                                                               __f},
                                                                                                                                                                               next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                  description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in)"),
                                                                                                                                                                                                  ffun: None,
                                                                                                                                                                                                  arrangement: (27,0),
                                                                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let ddlog_std::tuple2(ref expr, ref callee) = *<ddlog_std::tuple2<types__ast::ExprId, types__ast::ExprId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                      let (ref used_scope, ref used_in) = match *<types__inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                          types__inputs::Expression{id: _, kind: _, scope: ref used_scope, span: ref used_in} => ((*used_scope).clone(), (*used_in).clone()),
                                                                                                                                                                                                          _ => return None
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((ddlog_std::tuple4((*expr).clone(), (*callee).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue())
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                          description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in) by (callee)"),
                                                                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                          {
                                                                                                                                                                                                                              let ddlog_std::tuple4(ref expr, ref callee, ref used_scope, ref used_in) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ExprId, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                              Some((((*callee).clone()).into_ddvalue(), (ddlog_std::tuple3((*expr).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue()))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                          __f},
                                                                                                                                                                                                                          next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                             description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in), inputs::NameRef(.expr_id=callee, .value=name)"),
                                                                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                                                                             arrangement: (43,0),
                                                                                                                                                                                                                                             jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                 let ddlog_std::tuple3(ref expr, ref used_scope, ref used_in) = *<ddlog_std::tuple3<types__ast::ExprId, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                 let ref name = match *<types__inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                     types__inputs::NameRef{expr_id: _, value: ref name} => (*name).clone(),
                                                                                                                                                                                                                                                     _ => return None
                                                                                                                                                                                                                                                 };
                                                                                                                                                                                                                                                 Some((ddlog_std::tuple4((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue())
                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                             __f},
                                                                                                                                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                     description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in), inputs::NameRef(.expr_id=callee, .value=name) by (name, used_scope)"),
                                                                                                                                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         let ddlog_std::tuple4(ref expr, ref used_scope, ref used_in, ref name) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                         Some(((ddlog_std::tuple2((*name).clone(), (*used_scope).clone())).into_ddvalue(), (ddlog_std::tuple4((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                                                                     next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                        description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in), inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdFunc{.func=func}))"),
                                                                                                                                                                                                                                                                                        ffun: None,
                                                                                                                                                                                                                                                                                        arrangement: (61,4),
                                                                                                                                                                                                                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            let ddlog_std::tuple4(ref expr, ref used_scope, ref used_in, ref name) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                                            let (ref declared, ref func) = match *<crate::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                                                                crate::name_in_scope::NameInScope{name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                                                                                                                                                                                    types__ast::AnyId::AnyIdFunc{func: ref func} => ((*declared).clone(), (*func).clone()),
                                                                                                                                                                                                                                                                                                                                                                                    _ => return None
                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                _ => return None
                                                                                                                                                                                                                                                                                            };
                                                                                                                                                                                                                                                                                            Some((ddlog_std::tuple6((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*func).clone())).into_ddvalue())
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        __f},
                                                                                                                                                                                                                                                                                        next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                                                                description: std::borrow::Cow::from("arrange config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in), inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdFunc{.func=func})) by (func)"),
                                                                                                                                                                                                                                                                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                    let ddlog_std::tuple6(ref expr, ref used_scope, ref used_in, ref name, ref declared, ref func) = *<ddlog_std::tuple6<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId, types__ast::FuncId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                                                                    Some((((*func).clone()).into_ddvalue(), (ddlog_std::tuple5((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                                                                next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                                                                   description: std::borrow::Cow::from("config::EnableNoUseBeforeDef(.file=file, .config=_), inputs::Call(.expr_id=(expr@ ast::ExprId{.id=_, .file=file}), .callee=ddlog_std::Some{.x=callee}, .args=_), inputs::Expression(.id=expr, .kind=_, .scope=used_scope, .span=used_in), inputs::NameRef(.expr_id=callee, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdFunc{.func=func})), inputs::Function(.id=func, .name=ddlog_std::Some{.x=ast::Spanned{.data=_, .span=declared_in}}, .scope=decl_scope, .body=_, .exported=_)"),
                                                                                                                                                                                                                                                                                                                                   ffun: None,
                                                                                                                                                                                                                                                                                                                                   arrangement: (33,0),
                                                                                                                                                                                                                                                                                                                                   jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                       let ddlog_std::tuple5(ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<ddlog_std::tuple5<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                                                                                       let (ref declared_in, ref decl_scope) = match *<types__inputs::Function>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                                                                                                           types__inputs::Function{id: _, name: ddlog_std::Option::Some{x: types__ast::Spanned{data: _, span: ref declared_in}}, scope: ref decl_scope, body: _, exported: _} => ((*declared_in).clone(), (*decl_scope).clone()),
                                                                                                                                                                                                                                                                                                                                           _ => return None
                                                                                                                                                                                                                                                                                                                                       };
                                                                                                                                                                                                                                                                                                                                       if !(((&*decl_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                                                                                                                                                       Some(((NoUseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                   __f},
                                                                                                                                                                                                                                                                                                                                   next: Box::new(None)
                                                                                                                                                                                                                                                                                                                               })
                                                                                                                                                                                                                                                                                                            }))
                                                                                                                                                                                                                                                                                    })
                                                                                                                                                                                                                                                                 }))
                                                                                                                                                                                                                                         })
                                                                                                                                                                                                                      }))
                                                                                                                                                                                              })
                                                                                                                                                                           }))
                                                                                                                                                   }
                                                                                                                                        });
pub static __Rule_outputs_no_use_before_def_NoUseBeforeDef_3 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_use_before_def::NoUseBeforeDef[(outputs::no_use_before_def::NoUseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in}: outputs::no_use_before_def::NoUseBeforeDef)] :- __Prefix_0[((file: ast::FileId), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(object: ast::ExprId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)], inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(class: ast::ExprId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], inputs::Expression[(inputs::Expression{.id=(class: ast::ExprId), .kind=(_: ast::ExprKind), .scope=(decl_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Expression)], ((decl_scope != used_scope) and (used_in < declared_in)). */
                                                                                                                                        program::Rule::ArrangementRule {
                                                                                                                                            description: std::borrow::Cow::from( "outputs::no_use_before_def::NoUseBeforeDef(.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in) :- __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})), variable_decl::VariableDecl(.stmt=decl, .kind=_, .pattern=_, .value=ddlog_std::Some{.x=class}, .exported=_), inputs::ClassExpr(.expr_id=class, .elements=_), inputs::Expression(.id=class, .kind=_, .scope=decl_scope, .span=declared_in), ((decl_scope != used_scope) and (used_in < declared_in))."),
                                                                                                                                            arr: ( 0, 1),
                                                                                                                                            xform: XFormArrangement::Join{
                                                                                                                                                       description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name)"),
                                                                                                                                                       ffun: None,
                                                                                                                                                       arrangement: (43,0),
                                                                                                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                       {
                                                                                                                                                           let (ref file, ref expr, ref object, ref used_scope, ref used_in) = match *<ddlog_std::tuple5<types__ast::FileId, types__ast::ExprId, types__ast::ExprId, types__ast::ScopeId, types__ast::Span>>::from_ddvalue_ref(__v1) {
                                                                                                                                                               ddlog_std::tuple5(ref file, ref expr, ref object, ref used_scope, ref used_in) => ((*file).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone()),
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           let ref name = match *<types__inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                                                                                                               types__inputs::NameRef{expr_id: _, value: ref name} => (*name).clone(),
                                                                                                                                                               _ => return None
                                                                                                                                                           };
                                                                                                                                                           Some((ddlog_std::tuple4((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue())
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                               description: std::borrow::Cow::from("arrange __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name) by (name, used_scope)"),
                                                                                                                                                                               afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                               {
                                                                                                                                                                                   let ddlog_std::tuple4(ref expr, ref used_scope, ref used_in, ref name) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                   Some(((ddlog_std::tuple2((*name).clone(), (*used_scope).clone())).into_ddvalue(), (ddlog_std::tuple4((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue()))
                                                                                                                                                                               }
                                                                                                                                                                               __f},
                                                                                                                                                                               next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                  description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl}))"),
                                                                                                                                                                                                  ffun: None,
                                                                                                                                                                                                  arrangement: (61,2),
                                                                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let ddlog_std::tuple4(ref expr, ref used_scope, ref used_in, ref name) = *<ddlog_std::tuple4<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                      let (ref declared, ref decl) = match *<crate::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                          crate::name_in_scope::NameInScope{name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                                                                                              types__ast::AnyId::AnyIdStmt{stmt: ref decl} => ((*declared).clone(), (*decl).clone()),
                                                                                                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                                                                                                          },
                                                                                                                                                                                                          _ => return None
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((ddlog_std::tuple6((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*decl).clone())).into_ddvalue())
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                          description: std::borrow::Cow::from("arrange __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})) by (decl)"),
                                                                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                          {
                                                                                                                                                                                                                              let ddlog_std::tuple6(ref expr, ref used_scope, ref used_in, ref name, ref declared, ref decl) = *<ddlog_std::tuple6<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId, types__ast::StmtId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                              Some((((*decl).clone()).into_ddvalue(), (ddlog_std::tuple5((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                          __f},
                                                                                                                                                                                                                          next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                             description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})), variable_decl::VariableDecl(.stmt=decl, .kind=_, .pattern=_, .value=ddlog_std::Some{.x=class}, .exported=_)"),
                                                                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                                                                             arrangement: (86,0),
                                                                                                                                                                                                                                             jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                 let ddlog_std::tuple5(ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<ddlog_std::tuple5<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                 let ref class = match *<types__variable_decl::VariableDecl>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                     types__variable_decl::VariableDecl{stmt: _, kind: _, pattern: _, value: ddlog_std::Option::Some{x: ref class}, exported: _} => (*class).clone(),
                                                                                                                                                                                                                                                     _ => return None
                                                                                                                                                                                                                                                 };
                                                                                                                                                                                                                                                 Some((ddlog_std::tuple6((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue())
                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                             __f},
                                                                                                                                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                     description: std::borrow::Cow::from("arrange __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})), variable_decl::VariableDecl(.stmt=decl, .kind=_, .pattern=_, .value=ddlog_std::Some{.x=class}, .exported=_) by (class)"),
                                                                                                                                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         let ddlog_std::tuple6(ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<ddlog_std::tuple6<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId, types__ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                         Some((((*class).clone()).into_ddvalue(), (ddlog_std::tuple6((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                                                                     next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                                                                                                                                                                        description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})), variable_decl::VariableDecl(.stmt=decl, .kind=_, .pattern=_, .value=ddlog_std::Some{.x=class}, .exported=_), inputs::ClassExpr(.expr_id=class, .elements=_)"),
                                                                                                                                                                                                                                                                                        ffun: None,
                                                                                                                                                                                                                                                                                        arrangement: (17,0),
                                                                                                                                                                                                                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,___v2: &()) -> Option<DDValue>
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            let ddlog_std::tuple6(ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<ddlog_std::tuple6<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId, types__ast::ExprId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                                            Some((ddlog_std::tuple6((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue())
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        __f},
                                                                                                                                                                                                                                                                                        next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                                                                description: std::borrow::Cow::from("arrange __Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})), variable_decl::VariableDecl(.stmt=decl, .kind=_, .pattern=_, .value=ddlog_std::Some{.x=class}, .exported=_), inputs::ClassExpr(.expr_id=class, .elements=_) by (class)"),
                                                                                                                                                                                                                                                                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                    let ddlog_std::tuple6(ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<ddlog_std::tuple6<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId, types__ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                                                                    Some((((*class).clone()).into_ddvalue(), (ddlog_std::tuple5((*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                                                                next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                                                                   description: std::borrow::Cow::from("__Prefix_0[(file, expr, object, used_scope, used_in)], inputs::NameRef(.expr_id=object, .value=name), name_in_scope::NameInScope(.name=name, .scope=used_scope, .declared=(declared@ ast::AnyIdStmt{.stmt=decl})), variable_decl::VariableDecl(.stmt=decl, .kind=_, .pattern=_, .value=ddlog_std::Some{.x=class}, .exported=_), inputs::ClassExpr(.expr_id=class, .elements=_), inputs::Expression(.id=class, .kind=_, .scope=decl_scope, .span=declared_in)"),
                                                                                                                                                                                                                                                                                                                                   ffun: None,
                                                                                                                                                                                                                                                                                                                                   arrangement: (27,0),
                                                                                                                                                                                                                                                                                                                                   jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                       let ddlog_std::tuple5(ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<ddlog_std::tuple5<types__ast::ExprId, types__ast::ScopeId, types__ast::Span, internment::Intern<String>, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                                                                                       let (ref decl_scope, ref declared_in) = match *<types__inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                                                                                                           types__inputs::Expression{id: _, kind: _, scope: ref decl_scope, span: ref declared_in} => ((*decl_scope).clone(), (*declared_in).clone()),
                                                                                                                                                                                                                                                                                                                                           _ => return None
                                                                                                                                                                                                                                                                                                                                       };
                                                                                                                                                                                                                                                                                                                                       if !(((&*decl_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                                                                                                                                                       Some(((NoUseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                   __f},
                                                                                                                                                                                                                                                                                                                                   next: Box::new(None)
                                                                                                                                                                                                                                                                                                                               })
                                                                                                                                                                                                                                                                                                            }))
                                                                                                                                                                                                                                                                                    })
                                                                                                                                                                                                                                                                 }))
                                                                                                                                                                                                                                         })
                                                                                                                                                                                                                      }))
                                                                                                                                                                                              })
                                                                                                                                                                           }))
                                                                                                                                                   }
                                                                                                                                        });